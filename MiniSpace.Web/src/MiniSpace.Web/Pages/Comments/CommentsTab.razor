@using Blazorise.DeepCloner
@using MiniSpace.Web.Areas.Comments
@using MiniSpace.Web.DTO
@using MiniSpace.Web.DTO.Wrappers
@using MiniSpace.Web.Models.Comments
@using MiniSpace.Web.Pages.Comments.Dialogs
@using MudBlazor
@using Radzen
@using AlignItems = Radzen.AlignItems
@using DialogOptions = Radzen.DialogOptions
@using DialogService = Radzen.DialogService
@using Orientation = Radzen.Orientation
@inject DialogService DialogService
@inject ICommentsService CommentsService

<RadzenStack Gap="1rem" Orientation="Orientation.Vertical" JustifyContent="JustifyContent.SpaceBetween" Style="height: 100%;">
    <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Center" Gap="0.5rem">
        <RadzenButton Size="ButtonSize.Medium" Text="Create comment" ButtonStyle="ButtonStyle.Secondary"
                      Click="@(() => CreateRootComment())" />
        <RadzenButton Size="ButtonSize.Medium" Text="Sort by criteria"
                      Click="@OpenSearchCommentsDialog" />
    </RadzenStack>
    <RadzenRow AlignItems="AlignItems.Center">
        <RadzenColumn Size="12" SizeMD="12">
            @if (pageInitialized && commentsEmpty)
            {
                <h3>No comments have been added by students yet.</h3>
            }
            <CommentsTree Comments="Comments" StudentId="StudentId"
                          CreateSubComment="@CreateSubComment"
                          LoadSubComments="@LoadSubComments" 
                          LoadMoreSubComments="@LoadMoreSubComments" />
            @if (moreCommentsAvailable)
            {
                <RadzenButton Size="ButtonSize.Medium" Text="Load more comments"
                              Click="@LoadMoreComments" />
            }
        </RadzenColumn>
    </RadzenRow>
</RadzenStack>

@code {
    [Parameter]
    public string EventId { get; set; }
    [Parameter]
    public Guid StudentId { get; set; }

    private Guid eventId;
    private Guid studentId;
    
    private HashSet<CommentDto> Comments;
    
    private SearchCommentsModel SearchCommentsModel = new()
    {
        CommentContext = "Event",
        Pageable = new PageableDto()
        {
            Page = 1,
            Size = 5,
            Sort = new SortDto()
            {
                SortBy = new List<string>() { "lastUpdatedAt" },
                Direction = "des"
            }
        }
    };
    private CreateCommentModel CreateCommentModel = new()
    {
        CommentContext = "Event"
    };

    private bool pageInitialized;
    private bool moreCommentsAvailable;
    private bool commentsEmpty = true;
    
    protected override async Task OnInitializedAsync()
    {
        eventId = new Guid(EventId);
        studentId = StudentId;
        
        SearchCommentsModel.ContextId = eventId;
        CreateCommentModel.ContextId = eventId;
        CreateCommentModel.StudentId = studentId;
        await SearchComments();
        
        pageInitialized = true;
    }
    
    private async Task OpenCreateCommentDialog(string title)
    {
        await DialogService.OpenAsync<CreateCommentDialog>(title,
            new Dictionary<string, object>()
            {
                { "EventId", EventId },
                { "CreateCommentModel", CreateCommentModel }
            },
            new DialogOptions()
            {
                Width = "800px", Resizable = true, Draggable = true,
                AutoFocusFirstElement = false
            });
    }

    private async Task OpenSearchCommentsDialog()
    {
        await DialogService.OpenAsync<SearchCommentsDialog>("Sort your comments by criteria:",
            new Dictionary<string, object>()
            {
                { "EventId", EventId },
                { "SearchCommentsModel", SearchCommentsModel }
            },
            new DialogOptions()
            {
                Width = "800px", Resizable = true, Draggable = true,
                AutoFocusFirstElement = false
            });
        if (SearchCommentsModel.SearchingSubmitted)
        {
            SearchCommentsModel.SearchingSubmitted = false;
            await SearchComments();
        }
    }

    private async Task SearchComments()
    {
        Comments = [];
        SearchCommentsModel.Pageable.Page = 1;
        
        var response = await CommentsService.SearchRootCommentsAsync(SearchCommentsModel.ContextId,
            SearchCommentsModel.CommentContext, SearchCommentsModel.Pageable);
        if (response.Content != null)
        {
            Comments = response.Content.Content.ToHashSet();
            commentsEmpty = response.Content.Empty;
            moreCommentsAvailable = response.Content.Number < response.Content.TotalPages;
            
            if (moreCommentsAvailable)
            {
                Comments.Last().IsLast = true;
            }
        }
        else
        {
            commentsEmpty = true;
        }
        
        foreach (var comment in Comments)
        {
            if (comment.RepliesCount > 0)
            {
                comment.CanExpand = true;
            }
            
            var searchSubCommentsModel = SearchCommentsModel.DeepClone();
            searchSubCommentsModel.Pageable.Page = 1;
            
            var subResponse = await CommentsService.SearchSubCommentsAsync(SearchCommentsModel.ContextId,
                SearchCommentsModel.CommentContext, comment.Id, SearchCommentsModel.Pageable);
            if (subResponse.Content is { Empty: false })
            {
                comment.SubComments = subResponse.Content.Content.ToHashSet();
                var moreSubCommentsAvailable = subResponse.Content.Number < subResponse.Content.TotalPages;

                foreach (var subComment in comment.SubComments)
                {
                    subComment.Parent = comment;
                }

                if (moreSubCommentsAvailable)
                {
                    comment.SubComments.Last().IsLast = true;   
                }
            }
        }
        
        StateHasChanged();
    }
    
    private async Task LoadMoreComments()
    {
        List<CommentDto> moreComments = [];
        ++SearchCommentsModel.Pageable.Page;
        
        var response = await CommentsService.SearchRootCommentsAsync(SearchCommentsModel.ContextId,
            SearchCommentsModel.CommentContext, SearchCommentsModel.Pageable);
        if (response.Content != null)
        {
            moreComments = response.Content.Content.ToList();
            moreCommentsAvailable = response.Content.Number < response.Content.TotalPages;
            Comments.Last().IsLast = false;
            
            if (moreCommentsAvailable)
            {
                moreComments.Last().IsLast = true;
            }
        }

        foreach (var comment in moreComments)
        {
            if (comment.RepliesCount > 0)
            {
                comment.CanExpand = true;
            }
            
            var searchSubCommentsModel = SearchCommentsModel.DeepClone();
            searchSubCommentsModel.Pageable.Page = 1;
            
            var subResponse = await CommentsService.SearchSubCommentsAsync(searchSubCommentsModel.ContextId,
                searchSubCommentsModel.CommentContext, comment.Id, searchSubCommentsModel.Pageable);
            if (subResponse.Content != null)
            {
                comment.SubComments = subResponse.Content.Content.ToHashSet();
                var moreSubCommentsAvailable = subResponse.Content.Number < subResponse.Content.TotalPages;
                
                foreach (var subComment in comment.SubComments)
                {
                    subComment.Parent = comment;
                }
                
                if (moreSubCommentsAvailable)
                {
                    comment.SubComments.Last().IsLast = true;   
                }
            }
            
            Comments.Add(comment);
        }
        
        StateHasChanged();
    }

    private async Task CreateRootComment()
    {
        CreateCommentModel.ParentId = Guid.Empty;
        await OpenCreateCommentDialog("Create new comment:");
        if (CreateCommentModel.CreatingSubmitted)
        {
            CreateCommentModel.CreatingSubmitted = false;
            await SearchComments();
        }
    }

    private async Task CreateSubComment(CommentDto parentComment)
    {
        CreateCommentModel.ParentId = parentComment.Id;
        await OpenCreateCommentDialog("Reply for the comment:");
        if (CreateCommentModel.CreatingSubmitted)
        {
            CreateCommentModel.CreatingSubmitted = false;
            ++parentComment.RepliesCount;
        }
    }

    private async Task LoadSubComments(CommentDto parentComment)
    {
        var searchSubCommentsModel = SearchCommentsModel.DeepClone();
        searchSubCommentsModel.Pageable.Page = parentComment.SubCommentsPage = 1;
        
        var response = await CommentsService.SearchSubCommentsAsync(searchSubCommentsModel.ContextId,
            searchSubCommentsModel.CommentContext, parentComment.Id, searchSubCommentsModel.Pageable);
        if (response.Content != null)
        {
            parentComment.SubComments = response.Content.Content.ToHashSet();
            var moreSubCommentsAvailable = response.Content.Number < response.Content.TotalPages;
            
            foreach (var subComment in parentComment.SubComments)
            {
                subComment.Parent = parentComment;
            }

            if (moreSubCommentsAvailable)
            {
                parentComment.SubComments.Last().IsLast = true;   
            }
        }
    }
    
    private async Task LoadMoreSubComments(CommentDto lastComment)
    {
        var parentComment = lastComment.Parent;
        
        var searchSubCommentsModel = SearchCommentsModel.DeepClone();
        searchSubCommentsModel.Pageable.Page = ++parentComment.SubCommentsPage;
            
        var response = await CommentsService.SearchSubCommentsAsync(searchSubCommentsModel.ContextId,
            searchSubCommentsModel.CommentContext, parentComment.Id, searchSubCommentsModel.Pageable);
        if (response.Content != null)
        {
            IEnumerable<CommentDto> moreSubComments = response.Content.Content.ToHashSet();
            var moreSubCommentsAvailable = response.Content.Number < response.Content.TotalPages;
            parentComment.SubComments.Last().IsLast = false;
            
            foreach (var comment in moreSubComments)
            {
                comment.Parent = parentComment;
                parentComment.SubComments.Add(comment);
            }

            if (moreSubCommentsAvailable)
            {
                parentComment.SubComments.Last().IsLast = true;   
            }
        }
    }
}
